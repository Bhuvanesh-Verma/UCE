{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Unified Corpus Explorer <p>The Unified Corpus Explorer (UCE) is a generic NLP application developed by the Text Technology Lab that allows the automatic creation of a fully featured portal for your annotated corpora. UCE is standardized in the sense that it's dockerized, reusable, and follows strict schemata\u2014one of which is the UIMA format. To import data and set up your own UCE instance, it is required that the data is annotated or at least exists in UIMA format.</p> <p>This documentation includes step-by-step tutorials for developers as well as users, and shows easy-to-follow instructions. The easiest scenario\u2014one where the data already exists in UIMA format and simply needs to be set up and imported into the UCE instance\u2014can be done with Docker knowledge only.</p> <p>Below you find some running instances of different projects using UCE for their corpora</p>"},{"location":"#running-uce-instances","title":"Running UCE Instances","text":"<p>UCE is used by different projects to visualize their corpora and to provide a generic, but flexible webportal for their users. Here we list some of those UCE instances.</p> Url Project Description URL BIOfid The Specialised Information Service Biodiversity Research (BIOfid) provides access to current and historical biodiversity literature. URL PrismAI A dataset for the systematic detection of AI-generated text, containg both English and German texts from 8 domains, synthesized using state-of-the-art LLMs."},{"location":"about/about/","title":"About","text":"<p>The Unified Corpus Explorer is a novel solution for making UIMA-annotated corpora tangible. Herein, UCE stands as a generic interface that, given any corpus and its extracted UIMA-based annotations, makes the underlying data accessible through various features, including:</p> <ul> <li>Semantic search  </li> <li>Visualization</li> <li>Chatbot Integration  </li> <li>Integration of various UIMA-based annotations  </li> </ul> <p>UCE handles the import of necessary files, sets up a multi-microservice environment, and adapts to the specific needs of each corpus and its annotations. Configuration files enable customization of UCE, including:</p> <ul> <li>Appearance (e.g., color schemes and corporate identity)</li> <li>Selection of active features</li> <li>Integration of annotations</li> </ul> <p>Corpora</p> <p>UCE supports the incorporation of multiple corpora within the same instance.</p>"},{"location":"about/about/#annotate-and-publish-your-data","title":"Annotate and Publish your Data","text":"<p>UCE operates on UIMA-annotated corpora. If the data is already in that format, you can directly import the files through UCE's Corpus Importer.</p> <pre><code>graph LR\n    A[Corpus] ----&gt; B{Annotated?}\n    B ---&gt;|Yes| C[Importer]\n    B ---&gt;|No| D[\u2699 DUUI]\n    C ---&gt; E[\ud83c\udf0d UCE]\n    D ---&gt; C</code></pre> <p>If not, the easiest and most efficient way to transform data into UIMA format while also annotating it is by using the Docker Unified UIMA Interface (DUUI). Refer to our documentation to learn how to utilize DUUI to annotate and transform your corpus before importing it into UCE. Also, check our compatibility list of annotations to see which annotations UCE supports.</p>"},{"location":"about/about/#architecture","title":"Architecture","text":"<p>The Unified Corpus Explorer (UCE) is built on a modular (dockerized) microservice infrastructure. Below is an overview of the architectural flow, described from top to bottom:</p> \ud83d\udce5 Corpus Import and Enrichment <ul> <li>Corpus Importer (A)         Responsible for importing UIMA-annotated documents along with their associated configuration files. Additionally, it interfaces with external services (C and D) to perform enrichment tasks and data preprocessing, ensuring the corpus is optimally structured for downstream processing.     </li> </ul> \ud83e\udde0 AI &amp; NLP Access <ul> <li>Python Web Server (D)         Facilitates the generation of high-dimensional embedding spaces across multiple levels of representation. These embeddings are subsequently employed by other modules, including the integrated Retrieval-Augmented Generation (RAGBot) pipeline. The web server serves as a central access point for incorporating Natural Language Processing (NLP) and Artificial Intelligence (AI) components within UCE.     </li> </ul> \ud83d\uddc4\ufe0f Data Storage <ul> <li>PostgreSQL Database (B)         Provides persistent storage for fully processed and semantically enriched documents. In addition to traditional relational storage, it includes vector capabilities to support similarity-based retrieval using embedding vectors.     </li> <li>SPARQL Endpoint (C)         Supports the storage and querying of ontologies encoded in RDF or OWL formats. These ontologies serve as semantic backbones that enhance search precision and enable structured annotation within UCE.     </li> </ul> \ud83c\udf10 User Access <ul> <li>Web Portal (E)         Acts as the primary interface for users to interact with the system. It provides access to various functionalities, each of which is connected to backend microservices through color-coded connections, indicating underlying service dependencies and architectural integration.     </li> </ul> \ud83e\uddec Feature-Service Interactions <p>Each feature within UCE depends on a specific combination of annotations and backend services, denoted by shorthand references and color-coded wire connections depicted in the system architecture legend. Examples include:</p> <ul> <li>Embedding Search         Relies on services B (PostgreSQL), C (SPARQL), and D (Python Web Server) to function effectively.     </li> <li>Document Reader         Operates solely with service B (PostgreSQL) for retrieving and displaying annotated content.     </li> </ul> <p>This architectural overview provides a generalized representation of the system as it currently exists. Given the ongoing development of UCE, individual components, services, or interactions may evolve over time. The information presented here should be interpreted as a high-level conceptual framework rather than a static specification.     </p>"},{"location":"about/about/#features","title":"Features","text":"<p>Based on the outlined architecture, UCE provides the following features:</p> <ul> <li> <p> Document Reader</p> <p>Provides an interface for accessing and reading all documents within the corpus. Annotations are systematically highlighted to support structured analysis and interpretation. The reader accommodates multiple formats and facilitates efficient navigation across annotated segments.</p> </li> <li> <p> Fulltext Search</p> <p>Enables comprehensive full-text search across the entire corpus. An advanced mode supports Boolean operators such as <code>AND</code>, <code>OR</code>, and <code>NOT</code>, allowing for the formulation of complex and precise search queries. Search functionality is further enhanced through the integration of annotations and contextual filters.</p> </li> <li> <p> Ontology Enrichment</p> <p>Supports the integration of ontologies in RDF or OWL formats to enable semantically enriched search operations. Hierarchical structures, such as taxonomic or legal classifications, facilitate broader and more inferential retrieval strategies, contributing to the semantic understanding of the corpus.</p> </li> <li> <p> Semantic Role Labeling</p> <p>Incorporates Semantic Role Labeling (SRL) annotations to model predicate-argument structures within the text. This facilitates the formulation of semantically grounded queries by addressing the underlying question:</p> <p>Who performed which action, upon whom, and under what circumstances?</p> <p>SRL enhances analytical depth by representing event structures and participant roles explicitly.</p> </li> <li> <p> Embedding Search</p> <p>Facilitates semantic search by projecting documents into a high-dimensional vector space using embedding representations. This method supports cross-lingual and approximate semantic retrieval, making it suitable for fuzzy matching, multilingual corpora, and thematically clustered content exploration.</p> </li> <li> <p> Chatbot (RAGBot)</p> <p>Employs Retrieval-Augmented Generation (RAG) techniques to enable interactive querying of the corpus via a chatbot interface. Following preprocessing, users may engage in natural language dialogue with the system, which retrieves relevant content passages and generates contextually informed responses. This supports exploratory research and information retrieval.</p> </li> <li> <p> Visualization</p> <p>Offers a suite of visualization tools for structural and semantic analysis of the corpus. Available modalities include 2D and 3D graph-based representations, timeline visualizations, and clustering layouts. These visualizations enable the identification of patterns, anomalies, and structural relationships within large corpora.</p> </li> <li> <p> Wikidtion</p> <p>Automatically generates an interlinked hypertext knowledge base derived from the corpus. Each annotation and document is transformed into a dedicated wiki-style entry, promoting interpretability and contextual understanding through semantic linking. This facilitates knowledge integration and conceptual navigation akin to a domain-specific Wikipedia.</p> </li> </ul> <p>Depending on the user configuration and the annotations of the corpora, these features are flexibly enabled or disabled. The most minimal configuration for UCE is to import a corpus without any annotations and disable all processing and features, leaving only document reading and basic search functionality.</p> <p>Have a look yourself by referring to our running instances.</p>"},{"location":"about/annotations/","title":"Annotations","text":"<p>UCE is compatible with a variety of annotations, provided they exist within the UIMA format. Within UCE, these annotations are used situationally for features or search enhancements, depending on the annotation.</p> <p>Below you will find an ever-expanding list of importable and compatible annotations within UCE, ranging from standard Named-Entity annotations to more situational taxon or time annotations. All of these annotations can be generated and annotated within the corpus through the Docker Unified UIMA Interface.</p> OCR <p>Since much of the literature has yet to be digitized, UCE provides support for corpora containing documents that have undergone Optical Character Recognition (OCR) extraction. These annotations assist in reconstructing the physical layout of the pages within UCE.  More Details</p> Sentence <p>Divides the documents into their respective sentences.  More Details</p> Named-Entity <p>Extracts named entities from a document, categorizing them into four types: organization (ORG), person (PER), location (LOC), and miscellaneous (MISC).  More Details</p> Lemma, POS &amp; Morphological Features <p>Lemmatization reduces inflected words to their root form. Within UCE, searches are enhanced by considering these root forms.  More Details </p> Semantic Role Labels (SRL) <p>SRL identifies semantic relations between the lexical constituents of a sentence, assigning labels to words or phrases that indicate their semantic roles, such as agent, goal, or result.  More Details</p> Time <p>Extracts temporal expressions, including time and date formats, from a document, analogous to Named-Entity Recognition tasks.  More Details</p> UceDynamicMetadata <p>Offers a dynamic and easy way to annotate key-value filters, which are then imported and used within UCE for the creation of custom filters.  More Details</p> Taxon <p>The recognition of unambiguous names of biological entities is referred to as a taxon.  More Details</p> WikiLinks <p>Maps potential words and phrases to their corresponding Wikidata URLs, facilitating the retrieval and access of additional information.  More Details</p> GeoNames <p>The recognition of locations within texts and their annotation with hierarchical data, alternate and historical names, and tagging with unique identifiers. (Under construction) More Details</p>"},{"location":"about/ontologies/","title":"Ontologies","text":"<p>UCE already supports a collection of ontologies developed across various projects. These ontologies are fully supported out of the box, requiring no additional development within UCE to be functional.</p> <p>We are continuously working to expand this list\u2014similar to our efforts with compatible annotations. If you would like to contribute an ontology, you are welcome to submit a pull request or contact us directly.</p> <p>All ontologies must be in RDF or OWL format.</p> Biological Ontologies <p>As part of the BIOfid project, taxonomists have curated new biological taxonomies and extended existing ones. This ontology database builds upon the GBIF ontology and includes additional manually created taxonomies.  More Details</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>In general, UCE currently consists of 5 microservices, each dockerized and orchestrated via Docker Compose to form the application that is UCE. Among these 5 services, some are obligatory (must-haves) and some are optional (specific use cases).</p> Service Description Obligatory Web Portal The web portal provides access to UCE for the user. It is the heart of UCE, communicating with and orchestrating all other services. \u2705 PostgreSQL DB The PostgreSQL database is the main database within UCE. It stores all data in a structured way and adds vector support through the pgvector extension. \u2705 Corpus Importer              The Importer handles the importing of UIMA-annotated corpora. Given a path, it will load UIMA files and project them into the UCE environment.             Without the importer, there is currently no other way to get data into UCE              (IO REST endpoints in UCE exist, but aren't production-ready yet).          \u2705 RAG Service The RAG service is a Python web server that primarily enables access to machine learning and AI models. It is required to calculate embeddings and enable the RAG bot. \u274c Sparql Service The (Fuseki) Sparql service allows the integration of ontological hierarchies in RDF or OWL format into UCE's searches. \u274c <p>In the following, you will learn how to set up these services and how to get started with your own UCE instance for your data.</p> <p>Structure</p> <p>The following sections are split into two parts:</p> <ul> <li>Setting up UCE as a user (Docker). </li> <li>Setting up UCE as an active developer (local). </li> </ul> <p>Depending on your use case, you will either set up the development environment or simply build UCE, import your data, and use it.</p>"},{"location":"getting-started/configuration/","title":"Configurations","text":"<p>UCE has three different configuration levels and with it, three different config files. These levels are:</p> <ul> <li>INSTANCE </li> <li>CORPUS </li> <li>DEVELOPER</li> </ul> <p>If you're a user only setting up UCE via Docker, then the <code>DEVELOPER</code> level is of no interest to you. In the following, we outline the different configurations and their usage within UCE.</p> UCE Configuration (INSTANCE) <p>UCE is customizable in a variety of ways, including color scheme, corpora identity, metadata, and more. To inject your UCE instance with your configuration, the <code>uceConfig.json</code> file exists. Through it, you can model the UCE instance within JSON and then pass that <code>uceConfig.json</code> file into the Web Portal through the command line.</p> <p>You can copy the example <code>uceConfig.json</code> below and create your own configuration from it.</p> uceConfig.json uceConfig.json<pre><code>{\n  \"meta\": {\n    \"name\": \"John Doe Lab\",\n    \"version\": \"1.0.0\",\n    \"description\": \"The John Doe Lab works in the field of finance analysis and, in this context, gathers large amounts of data for their sentiment or entailment tasks. This data is made available through the &lt;b&gt;Finance&lt;/b&gt; corpus. Herein, ...\"\n  },\n  \"corporate\": {\n    \"team\": {\n      \"description\": \"The team behind the Finance corpus is part of the &lt;a target='_blank' href='https://www.john-doe-lab.org/'&gt;John Doe Lab&lt;/a&gt; of the Doe-University.\",\n      \"members\": [\n        {\n          \"name\": \"Prof. John Doe\",\n          \"role\": \"Supervisor\",\n          \"description\": \"Mr. Doe is the supervisor of the lab.\",\n          \"contact\": {\n            \"name\": \"Prof. Dr. John Doe\",\n            \"email\": \"doe@doe-university.de\",\n            \"website\": \"https://john-doe.org/team/john-doe/\",\n            \"address\": \"Doe-Street 10&lt;br/&gt;11111 Doe\"\n          },\n          \"image\": \"FILE::https://upload.wikimedia.org/wikipedia/commons/9/99/Sample_User_Icon.png\"\n        },\n      ]\n    },\n    \"contact\": {\n      \"name\": \"John Doe Lab\",\n      \"email\": \"doe@doe-university.de\",\n      \"website\": \"https://www.john-doe-lab.org/contact\",\n      \"address\": \"Doe-Street 10&lt;br/&gt;11111 Doe\"\n    },\n    \"website\": \"https://www.john-doe-lab.org\",\n    \"logo\": \"FILE::https://upload.wikimedia.org/wikipedia/commons/9/99/Sample_User_Icon.png\",\n    \"name\": \"John Doe Lab\",\n    \"primaryColor\": \"#00618f\",\n    \"secondaryColor\": \"rgba(35, 35, 35, 1)\"\n  },\n  \"settings\": {\n    \"rag\": {\n      \"model\": \"ChatGPT\",\n      \"apiKey\": \"\"\n    }\n  }\n}\n</code></pre> MetaCorporateSettings <p> Property Description name Name of your project or your lab, shown on the front page of the web portal. version Your personal version counts. description A description shown on the front page of the portal. Use it to describe your UCE instance. </p> <p> Property Description team Outline and display your team in a dedicated Teams-Tab within your UCE instance. team.description Describe the team working on this project. team.members Create a list of <code>member-objects</code> to model your team and each member. contact The contact information is shown in the footer of the webportal. Deposit contact information such as name, website and email for others to contact you through the UCE instance. website The website of your lab or corporation. logo The logo is shown in the top left of the web portal. You can inject the logo via a file path <code>FILE::{PATH}</code> (works with online paths as well) or directly through Base64-encoded images <code>BASE64::data:image/png;base64,{BASE64}</code>. name The name of your lab or corporation. primaryColor Set the primary color for the UCE web portal and model your color scheme. secondaryColor Set the secondary color for the UCE web portal and model your color scheme. </p> <p> Property Description rag Set the settings for the RAGbot (if applicable). rag.model The language model that UCE is supposed to power the RAGBot with. Currently, out of the box, only ChatGPT is applicable. apiKey The API key, if the RAGBot utilizes an LLM that is not hosted locally. In case of ChatGPT, for example, fill in your OpenAI API key. </p> <p>Within the source code, you also find a <code>defaultUceConfig.json</code> that you can mirror. This is also the configuration UCE uses if no explicit config is provided. Inject the <code>uceConfig.json</code> into the UCE web portal by means of command line arguments, as outlined in earlier sections.</p> Corpus Configuration (CORPUS) <p>As the name suggests, the <code>corpusConfig.json</code> holds metadata about a single corpus within UCE. Unlike the <code>uceConfig.json</code>, the corpus config is obligatory and needs to be imported by the Corpus-Importer.</p> <p>You can copy the example <code>corpusConfig.json</code> below and create your own configuration from it.</p> corpusConfig.json corpusConfig.json<pre><code>{\n  \"name\": \"Corpus_Name\",\n  \"author\": \"University Doe\",\n  \"language\": \"de-DE/en-EN/...\",\n  \"description\": \"The corpus was gathered as part of the John Doe project.\",\n  \"addToExistingCorpus\": true,\n\n  \"annotations\": {\n  \"annotatorMetadata\": false,\n\n    \"OCRPage\": false,\n    \"OCRParagraph\": false,\n    \"OCRBlock\": false,\n    \"OCRLine\": false,\n\n    \"srLink\": false,\n    \"lemma\": false,\n    \"namedEntity\": false,\n    \"sentence\": false,\n    \"taxon\": {\n      \"annotated\": false,\n      \"//comment\": \"[Are the taxons annotated with biofid onthologies through the 'identifier' property?]\",\n      \"biofidOnthologyAnnotated\": false\n    },\n    \"time\": false,\n    \"wikipediaLink\": false\n  },\n  \"other\": {\n    \"//comment\": \"[Is this corpus also available on https://sammlungen.ub.uni-frankfurt.de/? Either true or false]\",\n    \"availableOnFrankfurtUniversityCollection\": false,\n\n    \"includeTopicDistribution\": false,\n    \"enableEmbeddings\": false,\n    \"enableRAGBot\": false\n  }\n}\n</code></pre> Property Description name The name assigned to the corpus. author The entity or institution that created the corpus. language Languages included in the corpus, specified in locale format (e.g., \"de-DE\", \"en-EN\"). description A brief overview of the corpus and its purpose. addToExistingCorpus Boolean flag indicating whether to append this data to an existing corpus *(looks by name)*, or a new corpus should be created. annotations Object outlining how the corpus was annotated. annotations.annotatorMetadata Boolean flag indicating if metadata about the annotator is included. annotations.OCRPage Boolean flag indicating if OCR data at the page level is included. annotations.OCRParagraph Boolean flag indicating if OCR data at the paragraph level is included. annotations.OCRBlock Boolean flag indicating if OCR data at the block level is included. annotations.OCRLine Boolean flag indicating if OCR data at the line level is included. annotations.srLink Boolean flag indicating if semantic role links are annotated. annotations.lemma Boolean flag indicating if lemmatization is performed. annotations.namedEntity Boolean flag indicating if named entities are annotated. annotations.sentence Boolean flag indicating if sentence boundaries are annotated. annotations.taxon Object containing details about taxon annotations. annotations.taxon.annotated Boolean flag indicating if taxons are annotated. annotations.taxon.biofidOnthologyAnnotated Boolean flag indicating if taxons are annotated with biofid ontologies through the 'identifier' property. annotations.time Boolean flag indicating if temporal expressions are annotated. annotations.wikipediaLink Boolean flag indicating if Wikipedia links are included. other Object containing additional properties related to the corpus. The following flags require the setup of the RAG-Service. other.includeTopicDistribution Boolean flag indicating if topic distribution data is included. If enabled, the Corpus-Importer will create and cache those upon import. other.enableEmbeddings Boolean flag indicating if embeddings should be enabled. If enabled, the Corpus-Importer will create and cache those upon import. other.enableRAGBot Boolean flag indicating if the RAGBot feature should be enabled. Common Configuration (DEVELOPER) <p>In the source code's <code>uce.common</code> module, you'll find a <code>common.conf</code> file. In it, you can adjust and edit any configurations needed to run the application, such as DB connection strings, API endpoints, and the like. To properly run UCE in a development setting, you need to ensure that all the local connection strings match your setup. For that, the most relevant ones are:</p> Property Description rag.webserver.base.url The base url to the RAG-service's webserver (if setup), e.g.: <code>http://localhost:5678/.</code> sparql.host The base url to the Sparql-service's webserver (if setup), e.g.: <code>http://localhost:3030/</code> sparql.endpoint The endpoint of the Sparql-service's webserver, e.g.: <code>my-ontology/sparql</code> postgresql.hibernate.connection.url The connection string to the Postgresql-DB-service, e.g.: <code>jdbc:postgresql://localhost:5433/uce</code> <p>You'll also find two more files, called <code>common-release.conf</code> and <code>common-debug.conf</code>. Since, for the release, most of the connections differ from the local setup, you can store your local/release config in separate files and copy-paste the needed configuration into <code>common.conf</code> depending on the case. Only the <code>common.conf</code> file is used within UCE \u2014 the other two are ignored.</p>"},{"location":"getting-started/corpus-importer/","title":"Corpus Importer","text":"<p>Prerequisites</p> <p>This section requires that you have already set up the PostgreSQL DB and, preferably, the Web Portal. If not, refer to the respective documentation.</p> <p>The Corpus-Importer is a Java application that transforms and imports UIMA-annotated data from a local path into the UCE environment. Depending on the configuration, it also performs post-processing of the data, such as the creation of embedding spaces.</p> <p>UIMA</p> <p>If the data is not yet available in UIMA format, refer to the respective documentation, which also utilizes the Docker Unified UIMA Interface to transform, process, and annotate the data in UIMA format the best way possible. After having transformed your data, proceed here.</p>"},{"location":"getting-started/corpus-importer/#folder-structure","title":"Folder Structure","text":"<p>Having set up the database and the web portal (locally or via docker), all that is left to do is to tell the importer where to import from and start it.</p> <p>For this, the importer always requires the following folder structure:</p> Required Folder Structure<pre><code>\ud83d\udcc1 corpus_a\n\u2502   \ud83d\udcc4 corpusConfig.json\n\u2514\u2500\u2500\u2500\ud83d\udcc1 input\n    \u2502   \ud83d\udcc4 uima_doc_1.xmi\n    \u2502   \ud83d\udcc4 uima_doc_2.xmi\n    \u2502   \ud83d\udcc4 ...\n    \u2502   \ud83d\udcc4 uima_doc_n.xmi\n</code></pre> <p>where <code>corpusConfig.json</code> holds metadata, and the <code>input</code> folder contains the actual UIMA files for a single corpus.</p> <p>Input Structure</p> <p>As of now, the importer will recursively walk through the <code>input</code> folder, so every <code>.xmi</code> file in any subfolder will be considered.</p>"},{"location":"getting-started/corpus-importer/#user-setup","title":"User Setup","text":"<p>Open the <code>docker-compose.yaml</code> file (if you haven't created the <code>.env</code> file yet, see here) and locate the <code>uce-importer</code> service. Within it, mount all local paths to the corpora you want to import using the structure described above, and map them like so: </p> <pre><code>volumes:\n    - \"./path/to/my_corpora/corpus_a:/app/input/corpora/corpus_a\"\n    - \"./path/to/other_corpora/corpus_b:/app/input/corpora/corpus_b\"\n    - \"...\"\n</code></pre> <p>You can mount as many corpora as you like using the same structure. Remember that you can adjust the amount of threads used through the <code>.env</code> file.</p> <p>Afterwards, simply start the importer through the compose:</p> <pre><code>docker-compose up --build uce-importer\n</code></pre>"},{"location":"getting-started/corpus-importer/#developer-setup","title":"Developer Setup","text":"<p>In the source code, identify the module <code>uce.corpus-importer</code> and set up your IDE:</p> <p>Setup</p> <ul> <li>Add a new <code>Application</code> configuration  </li> <li>UCE is developed in Java 21 </li> <li>Set <code>-cp corpus-importer</code> </li> <li>Main class: <code>org.texttechnologylab.App</code> </li> <li>CLI arguments are obligatory:<ul> <li><code>-src \"./path/to/your_corpus/\"</code></li> <li><code>-num 1</code></li> <li><code>-t 1</code></li> </ul> </li> <li>Maven should automatically download and index the dependencies. If, for some reason, it does not, you can force an update via <code>mvn clean install -U</code> (in IntelliJ, open <code>Execute Maven Goal</code>, then enter the command).</li> </ul> <p>Open the <code>common.conf</code> file and adjust the database connection parameters to match your database (port, host, etc.). Now start the importer and import your corpus. Refer to CLI Arguments for a full list of possible parameters.</p> <p>Logs</p> <p>The importer logs to both the PostgreSQL database (tables <code>uceimport</code> and <code>importlog</code>) and the local <code>logs</code> directory within the container. Both logs also appear in the standard output of the console.</p>"},{"location":"getting-started/corpus-importer/#cli-arguments","title":"CLI Arguments","text":"Argument Description <code>-src</code> <code>--importSrc</code> The path to the corpus source where the UIMA-annotated files are stored. <code>-srcDir</code> <code>--importDir</code> Unlike <code>-src</code>, <code>-srcDir</code> is the path to a directory that holds multiple importable <code>src</code> paths. The importer will check for folders within this directory, where each folder should be an importable corpus with a corpusConfig.json and its input UIMA-files. Those are then imported. <code>-num</code> <code>--importerNumber</code> When starting multiple importers, assign an id to each instance by counting up from 1 to n (not relevant as off now, just set it to 1). <code>-t</code> <code>--numThreads</code> UCE imports asynchronous. Decide with how many threads, e.g. 4-8-16. By default, this is single threaded."},{"location":"getting-started/fuseki-sparql/","title":"Sparql Service","text":"<p>The (Fuseki) Sparql service allows the integration of ontological hierarchies in RDF or OWL format into UCE's searches. It does so through a SPARQL graph database which stores RDF triplets.</p> <p>Out-of-the-box Ontologies</p> <p>Please refer to our list of plug-and-play Ontologies to see what ontologies have already been made accessible in UCE without you having to  develop anything. We are continuously expanding plug-and-play compatibility with other ontologies, and if you want to incorporate your own compatibility into UCE, feel free to make a pull request or get in touch!</p>"},{"location":"getting-started/fuseki-sparql/#user-setup","title":"User Setup","text":"<p>For this, the following parameters in the <code>.env</code> file need to be set correctly:</p> <pre><code>TDB2_DATA=./../tdb2-database\nTDB2_ENDPOINT=tdb2-database-name\n</code></pre> <p>where <code>TDB2_DATA</code> is the local path to your TDB2 database and <code>TDB2_ENDPOINT</code> is the name under which this database will be queryable. This endpoint must match the first part of the <code>sparql.endpoint</code> parameter in the <code>common.conf</code> file (<code>tdb2-database-name/sparql</code>).</p> <p>Afterwards, simply start the <code>uce-fuseki-sparql</code> container:</p> <pre><code>docker-compose up --build uce-fuseki-sparql\n</code></pre>"},{"location":"getting-started/fuseki-sparql/#developer-setup","title":"Developer Setup","text":"<p>You can easily set up the SPARQL database as outlined in the User Setup. However, for more efficient testing and to take advantage of the web interface provided by Apache Jena, it may be advisable to install a local Fuseki SPARQL instance as well. For that:</p> <ul> <li>Download the latest Apache Jena Binary Distribution.</li> <li>Unzip the archive, navigate to the folder, and start the SPARQL server (requires Java to be installed): <pre><code>java -Xmx8G -jar fuseki-server.jar --update\n</code></pre> <code>--update</code> makes the database persistent.</li> <li>By default, the SPARQL database and its web interface are accessible at <code>http://localhost:3030</code>.</li> <li>You can now create a new database through the Web UI. The name of the database will also serve as the endpoint <code>/db_name</code>.</li> </ul> <p>Web UI &amp; Import Option</p> <p>When installing locally and opening the web UI, you can create a new database and use the <code>Import</code> button to import RDF and OWL files directly. Once the database has been populated, you will find the corresponding <code>TDB2</code> database as a folder within your program directory (likely under <code>run/databases</code>). You can simply mount this folder as the <code>TDB2_DATA</code> location.</p> tdb.lock <p>The database will generate a <code>tdb.lock</code> file to prevent multiple instances from accessing the same TDB2 database simultaneously. Be mindful of this, as it often leads to errors when overlooked.</p> Disk Space <p>When importing large volumes of new triplets, the SPARQL database generates log and transaction files, which can quickly consume significant disk space and bloat the database. You can heavily reduce the size and reclaim unnecessary space by using the <code>/compact</code> endpoint once your importing is finished.</p>"},{"location":"getting-started/uima-duui/","title":"UIMA & DUUI","text":"<p>As mentioned, UCE works on UIMA-annotated data, which enables the standardized storing, processing, and further utilization of your corpora and annotations. The easiest way to annotate large amounts of data in parallel is through the Docker Unified UIMA Interface (DUUI).</p> <p>In the following, we will first briefly outline the technologies, explain their advantages, and finally present small tutorials to help you get started. As a result, you will build the following pipeline, which leads to your UCE instance:</p> <pre><code>graph LR\n    A[Corpus] ---&gt; B{Annotated?}\n    B ---&gt;|No| D[\u2699 DUUI]\n    C[Importer] ---&gt; E[\ud83c\udf0d UCE]\n    D ---&gt; C</code></pre> <p>Annotations</p> <p>It is not required to use DUUI to produce UIMA-annotated data. You can choose any technique you prefer\u2014at the end of the day, UCE simply needs UIMA files and, if you want to use annotations, it utilizes the types outlined in our annotations list.</p>"},{"location":"getting-started/uima-duui/#uima","title":"UIMA","text":""},{"location":"getting-started/uima-duui/#duui","title":"DUUI","text":""},{"location":"getting-started/uima-duui/#tut-1","title":"Tut 1","text":""},{"location":"getting-started/uima-duui/#tut-2","title":"Tut 2","text":""},{"location":"getting-started/webportal/","title":"Web Portal","text":"<p>The heart of UCE is its webportal, which, alongside the Postgresql database, are the primary microservices we will setup first, as these services are obligatory.</p>"},{"location":"getting-started/webportal/#user-setup","title":"User Setup","text":"<p>When building from source (the option to pull finished images will be added soon), clone the UCE repository:</p> <pre><code>git clone https://github.com/texttechnologylab/UCE.git\n</code></pre> <p>In the root folder, create a <code>.env</code> file that holds the variables for the <code>docker-compose.yaml</code> file. E.g.:</p> .env<pre><code>UCE_CONFIG_PATH=./../uceConfig.json\nJVM_ARGS=-Xmx8g\nTDB2_DATA=./../tdb2-database\nTDB2_ENDPOINT=tdb2-database-name\nIMPORTER_THREADS=1\n</code></pre> <ul> <li><sup><code>UCE_CONFIG_PATH</code>: The local path to the UceConfig that injects personal customization into the UCE instance. If none is given, UCE will fallback to a default configuration.</sup></li> <li><sup><code>JVM_ARGS</code>: Only relevant if the Sparql microservice is added. Specifies the maximum size, in bytes, of the memory allocation pool for the service.</sup></li> <li><sup><code>TDB2_DATA/ENDPOINT</code>: Only relevant if the Sparql microservice is added. The local path to a TDB2 database and the name of the endpoint, this database will be exposed to (e.g.: /uce-ontology).</sup></li> <li><sup><code>IMPORTER_THREADS</code>: The amount of parallel threads used by the Importer to import the corpora (standard values are 4, 8 or 16, depending on your setup).</sup></li> </ul> <p>Start the relevant docker containers:</p> <pre><code>docker-compose up --build uce-postgresql-db uce-web\n</code></pre> <p>The web instance, by default, is reachable under: <code>http://localhost:8008</code>.</p> <p>Problems?</p> <p>If the webportal container isn't working, it most likely can't connect to the database. In that case, you can check the connection strings within the <code>common.conf</code> file in the source code. For the docker setup, the content of this file should match the <code>common-release.conf</code>, which should again match the exposed ports in the <code>docker-compose.yaml</code>.</p>"},{"location":"getting-started/webportal/#developer-setup","title":"Developer Setup","text":"<p>Developer Code</p> <p>Please refer to the Developer Code for details on how to correctly develop UCE.</p> <p>Clone the UCE repo and switch to the <code>develop</code> branch:</p> <pre><code>git clone https://github.com/texttechnologylab/UCE.git\ngit fetch --all\ngit checkout origin develop\n</code></pre> <p>Before opening the repo in an IDE of your choice (but for this documentation, we will always refer to IntelliJ), we have to setup the database first.</p>"},{"location":"getting-started/webportal/#database","title":"Database","text":"<p>To set up the PostgreSQL database, you can either use a Docker image (refer to User Setup to do so via the compose file or simply pull the official pgvector image) or install the database locally. When installing it locally, you must install the <code>pgvector</code> extension, as we configure PostgreSQL to work with high-dimensional embedding vectors for UCE. This requires a manual but simple installation.</p> <p>Local Installation</p> <p>If installed locally, you also need to manually create a database called <code>uce</code>, with the owner set to <code>postgres</code> and the default password set to <code>1234</code>. If you adjust any of these parameters, you must also update the corresponding values in the source code's <code>common.conf</code>.</p> <p>Respectively, when running the container from the official image (and not UCE's docker-compose), pass these parameters into the container: <pre><code>POSTGRES_DB: uce\nPOSTGRES_USER: postgres\nPOSTGRES_PASSWORD: 1234\n</code></pre></p>"},{"location":"getting-started/webportal/#web","title":"Web","text":"<p>If the PostgreSQL DB is running, start by opening IntelliJ from within the <code>uce.portal</code> folder (not the root of the repo) and setting up the IDE for the web portal:</p> <p>Setup</p> <ul> <li>Add a new <code>Application</code> configuration  </li> <li>UCE is being developed in Java 21 </li> </ul> Missing JDK Version? <p>(If the Java 21 SDK is missing, you need to install it. IntelliJ offers a build-in way for that through <code>Menu</code> -&gt; <code>Project Structure</code> -&gt; <code>Project</code> -&gt; Open the <code>SDK dropdown</code> -&gt; <code>Download JDK</code> and download any 21 version.) </p> <ul> <li>Set <code>-cp web</code> </li> <li>Main class: <code>org.texttechnologylab.App</code> </li> <li>Program arguments can be left empty for now. For a list of potential CLI arguments, refer to the documentation.</li> <li>Maven should automatically download and index the dependencies. If, for some reason, it does not, you can force an update via <code>mvn clean install -U</code> (in IntelliJ, open <code>Execute Maven Goal</code>, then enter the command).</li> </ul> <p>Now start the web portal. The default URL is <code>http://localhost:4567</code> and, if done correctly, the portal will appear with no corpora available. We will now set up the Corpus-Importer to import corpora.</p> <p>Java Version Error?</p> <p>Make sure that IntelliJ's Java compiler is also set to match the target bytecode version 21. Otherwise, startup will result in an error. You can check this via <code>Settings</code> \u2192 <code>Build, Execution, Deployment</code> \u2192 <code>Compiler</code> \u2192 <code>Java Compiler</code>.</p>"},{"location":"getting-started/webportal/#cli-arguments","title":"CLI Arguments","text":""},{"location":"getting-started/webportal/#web-portal","title":"Web Portal","text":"Argument Description <code>-cf</code> <code>--configFile</code> The local path to the uceConfig.json. If started through a Docker container, remember to first mount the local path and then map the <code>-cf</code> path to the mounted Docker path. <code>-cj</code> <code>--configJson</code> Instead of passing the UCE configuration through a JSON file, you can also directly pass in the JSON."}]}